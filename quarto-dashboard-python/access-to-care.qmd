---
title: "Access to Care"
format:
  dashboard:
    theme: custom-theme.scss
    expandable: false
server: shiny
---

```{python}
#| context: setup
import polars as pl
import plotly.graph_objects as go
from shiny import render, reactive, ui as core_ui
from shiny.express import input, ui
from shinywidgets import render_plotly
import warnings
import numpy as np
warnings.filterwarnings('ignore')

# Read data
us_counties = pl.read_parquet("data/us_counties.parquet")
us_states = pl.read_parquet("data/us_states.parquet")
us_hex_positions = pl.read_parquet("data/us_hex_positions.parquet")
us_atc_county_polygons = pl.read_parquet("data/us_atc_county_polygons.parquet")
us_large_cities = pl.read_parquet("data/us_large_cities.parquet")

# Add below/above counts to us_states
below_counts = (
    us_counties.filter(pl.col("pred_status") == "below")
    .group_by("state")
    .agg(pl.count().alias("below"))
)
above_counts = (
    us_counties.filter(pl.col("pred_status") == "above")
    .group_by("state")
    .agg(pl.count().alias("above"))
)
us_states = us_states.join(below_counts, on="state", how="left").join(above_counts, on="state", how="left")
us_states = us_states.with_columns([
    pl.col("below").fill_null(0),
    pl.col("above").fill_null(0)
])

# Prepare state list
state_list = ["All US"] + sorted(us_states["state_name"].to_list())

us_choices = ["Population", "No. of Hospitals", "Below model", "Above model"]

def format_number(x):
    """Format large numbers with K/M suffix"""
    if x >= 1_000_000:
        return f"{x/1_000_000:.1f}M"
    elif x >= 1_000:
        return f"{x/1_000:.1f}K"
    else:
        return str(int(x))

def create_hex_polygons(centers_df, size=0.5):
    """Create hexagon polygon coordinates from center points"""
    import numpy as np

    hexagons = []
    for row in centers_df.iter_rows(named=True):
        angles = np.linspace(np.pi/6, 2*np.pi + np.pi/6, 7)
        hex_x = row['x'] + size * np.cos(angles)
        hex_y = row['y'] + size * np.sin(angles)

        for i in range(len(angles)):
            hexagons.append({
                'state': row['state'],
                'state_name': row['state_name'],
                'x': hex_x[i],
                'y': hex_y[i],
                'order': i
            })

    return pl.DataFrame(hexagons)
```

# State info

## Row {height=20%}

### Column

```{python}
ui.input_select(
    id="state",
    label="Select a State:",
    choices=state_list,
    selected="All US"
)
```

### Column

```{python}
@render.express
def population_box():
    selected = input.state()
    if selected == "All US":
        data = us_states
    else:
        data = us_states.filter(pl.col("state_name") == selected)
    total = data["population"].sum()

    ui.value_box(
        title="Population",
        value=format_number(total),
        showcase=ui.HTML('<i class="bi bi-person"></i>'),
        showcase_layout="bottom"
    )
```

### Column

```{python}
@render.express
def hospitals_box():
    selected = input.state()
    if selected == "All US":
        data = us_states
    else:
        data = us_states.filter(pl.col("state_name") == selected)
    total = data["hospitals"].sum()

    ui.value_box(
        title="Hospitals",
        value=format_number(total),
        showcase=ui.HTML('<i class="bi bi-hospital"></i>'),
        showcase_layout="bottom"
    )
```

### Column

```{python}
@render.express
def counties_box():
    selected = input.state()
    if selected == "All US":
        data = us_counties
    else:
        data = us_counties.filter(pl.col("state_name") == selected)

    ui.value_box(
        title="Counties",
        value=str(len(data)),
        showcase=ui.HTML('<i class="bi bi-geo-alt"></i>'),
        showcase_layout="bottom"
    )
```

### Column

```{python}
@render.express
def underserved_box():
    selected = input.state()
    if selected == "All US":
        data = us_counties
    else:
        data = us_counties.filter(pl.col("state_name") == selected)
    below = data.filter(pl.col("pred_status") == "below")

    ui.value_box(
        title="Underserved",
        value=str(len(below)),
        showcase=ui.HTML('<i class="bi bi-clipboard2-pulse"></i>'),
        showcase_layout="bottom"
    )
```

## Row {height=80%}

### {.sidebar}

```{python}
@render.express
def view_options():
    selected = input.state()
    if selected == "All US":
        choices = ["Population", "No. of Hospitals", "Below model", "Above model"]
    else:
        choices = ["Model", "Population", "Hospitals"]

    ui.input_radio_buttons(
        id="view",
        label=ui.strong("Select a view:"),
        choices=choices,
        inline=True
    )

ui.tags.br()

ui.input_action_button(
    id="reset_btn",
    label="Reset"
)

ui.tags.hr()

ui.tags.p(
    ui.tags.em("Sources: Centers of Medicine & Medicaid services (2025), and US Census Bureau (2024).")
)
```

### Column

```{python}
# Add JavaScript to capture Plotly click events
ui.tags.script(ui.HTML("""
$(document).on('shiny:connected', function() {
    function attachClickHandler() {
        var plotlyDivs = document.querySelectorAll('.js-plotly-plot');

        plotlyDivs.forEach(function(plot) {
            plot.on('plotly_click', function(data) {
                if (data.points && data.points.length > 0) {
                    var point = data.points[0];

                    var customdata = point.customdata ||
                                   (point.data && point.data.customdata) ||
                                   (point.fullData && point.fullData.customdata);

                    if (customdata && Array.isArray(customdata) && customdata.length > 0) {
                        customdata = customdata[0];
                    }

                    var traceName = point.data ? point.data.name : null;

                    Shiny.setInputValue('map_clicked', {
                        customdata: customdata,
                        traceName: traceName,
                        time: new Date().getTime()
                    }, {priority: 'event'});
                }
            });
        });
    }

    attachClickHandler();
    setTimeout(attachClickHandler, 500);
    setTimeout(attachClickHandler, 1500);

    $(document).on('shiny:value', function(event) {
        if (event.name === 'state_map') {
            document.querySelectorAll('.js-plotly-plot').forEach(function(plot) {
                plot._clickHandlerAttached = false;
            });
            setTimeout(attachClickHandler, 100);
            setTimeout(attachClickHandler, 500);
        }
    });
});
"""))

@render_plotly
def state_map():
    # Get selected state data
    selected = input.state()
    view = input.view()

    if selected == "All US":
        # Create hex map for US states
        plot_data = us_states

        if view == "Population":
            var = "population"
            fill_label = "Population"
            colorscale = [[0, "#ffffff"], [1, "#0072B2"]]
        elif view == "No. of Hospitals":
            var = "hospitals"
            fill_label = "Hospitals"
            colorscale = [[0, "#ffffff"], [1, "#0072B2"]]
        elif view == "Below model":
            var = "below"
            fill_label = "Underserved"
            colorscale = [[0, "#ffffff"], [1, "#CC79A7"]]
        elif view == "Above model":
            var = "above"
            fill_label = "Overserved"
            colorscale = [[0, "#ffffff"], [1, "#0072B2"]]
        else:
            var = "hospitals"
            fill_label = "Hospitals"
            colorscale = [[0, "#ffffff"], [1, "#0072B2"]]

        # Join state data with hex positions
        hex_data = us_hex_positions.join(
            plot_data.select(["state", "state_name", var]),
            on="state",
            how="left"
        ).to_pandas()

        # Create hexagon polygons for each state
        fig = go.Figure()

        for _, state_row in hex_data.iterrows():
            # Create hexagon coordinates
            angles = np.linspace(np.pi/6, 2*np.pi + np.pi/6, 7)
            hex_x = state_row['x'] + 0.58 * np.cos(angles)
            hex_y = state_row['y'] + 0.58 * np.sin(angles)

            # Normalize value for color
            val = state_row[var]
            norm_val = (val - hex_data[var].min()) / (hex_data[var].max() - hex_data[var].min()) if hex_data[var].max() > hex_data[var].min() else 0

            # Interpolate color
            if colorscale[1][1] == "#CC79A7":
                color = f"rgba(204, 121, 167, {0.3 + 0.7 * norm_val})"
            else:
                color = f"rgba(0, 114, 178, {0.3 + 0.7 * norm_val})"

            # Create customdata array with one entry per point in the polygon
            customdata_array = [[state_row['state_name'], val]] * len(hex_x)

            fig.add_trace(go.Scatter(
                x=hex_x,
                y=hex_y,
                fill="toself",
                fillcolor=color,
                line=dict(color="#cccccc", width=1),
                mode="lines",
                hovertemplate="<extra></extra>",
                customdata=customdata_array,
                name=state_row['state'],
                showlegend=False
            ))

            # Add state abbreviation text
            fig.add_trace(go.Scatter(
                x=[state_row['x']],
                y=[state_row['y']],
                mode="text",
                text=state_row['state'],
                textfont=dict(size=10, color="black"),
                hoverinfo="skip",
                showlegend=False
            ))

        fig.update_layout(
            title=f"United States - {fill_label}",
            xaxis=dict(visible=False, scaleanchor="y", scaleratio=1),
            yaxis=dict(visible=False),
            hovermode="closest",
            plot_bgcolor="white",
            height=500,
            margin=dict(l=0, r=0, t=30, b=0),
            clickmode="event+select",
            uirevision="constant"
        )

    else:
        # County-level geographic map
        plot_data = us_atc_county_polygons.filter(pl.col("state_name") == selected).to_pandas()
        county_data = us_counties.filter(pl.col("state_name") == selected).to_pandas()
        city_data = us_large_cities.filter(pl.col("state") == plot_data["state"].iloc[0]).filter(pl.col("position") <= 3).to_pandas()

        if view == "Model":
            var = "pred_status"
            fill_label = "Model results"
            use_categorical = True
        elif view == "Population":
            var = "population"
            fill_label = "Population"
            use_categorical = False
        elif view == "Hospitals":
            var = "hospitals"
            fill_label = "Hospitals"
            use_categorical = False
        else:
            var = "hospitals"
            fill_label = "Hospitals"
            use_categorical = False

        fig = go.Figure()

        if use_categorical:
            color_map = {"above": "#0072B2", "below": "#CC79A7", "ok": "#009E73"}
            label_map = {"above": "Above", "below": "Below", "ok": "At Level"}

            for group_id in plot_data['group'].unique():
                group_data = plot_data[plot_data['group'] == group_id]
                if len(group_data) > 0:
                    status = group_data[var].iloc[0]
                    fips = group_data['fips'].iloc[0]
                    county_name = group_data['county_name'].iloc[0]

                    # Get county details for hover
                    county_info = county_data[county_data['fips'] == fips]
                    if len(county_info) > 0:
                        pop = format_number(county_info['population'].iloc[0])
                        hosp = int(county_info['hospitals'].iloc[0])
                        hover_template = f"<b>{county_name}</b><br>Status: {label_map.get(status, status)}<br>Population: {pop}<br>Hospitals: {hosp}<extra></extra>"
                    else:
                        hover_template = f"<b>{county_name}</b><br>Status: {label_map.get(status, status)}<extra></extra>"

                    # Create customdata array with one entry per point in the polygon
                    customdata_array = [[fips, county_name]] * len(group_data)

                    fig.add_trace(go.Scatter(
                        x=group_data['x'],
                        y=group_data['y'],
                        fill="toself",
                        fillcolor=color_map.get(status, "#999999"),
                        line=dict(color="#cccccc", width=0.5),
                        mode="lines",
                        hovertemplate=hover_template,
                        customdata=customdata_array,
                        name=label_map.get(status, status),
                        showlegend=False,
                        opacity=0.8
                    ))
        else:
            for group_id in plot_data['group'].unique():
                group_data = plot_data[plot_data['group'] == group_id]
                if len(group_data) > 0:
                    val = group_data[var].iloc[0]
                    fips = group_data['fips'].iloc[0]
                    county_name = group_data['county_name'].iloc[0]

                    # Normalize value for color
                    min_val = plot_data[var].min()
                    max_val = plot_data[var].max()
                    norm_val = (val - min_val) / (max_val - min_val) if max_val > min_val else 0

                    color = f"rgba(0, 114, 178, {0.3 + 0.7 * norm_val})"

                    hover_template = f"<b>{county_name}</b><br>{fill_label}: {format_number(val)}<extra></extra>"

                    # Create customdata array with one entry per point in the polygon
                    customdata_array = [[fips, county_name]] * len(group_data)

                    fig.add_trace(go.Scatter(
                        x=group_data['x'],
                        y=group_data['y'],
                        fill="toself",
                        fillcolor=color,
                        line=dict(color="#cccccc", width=0.5),
                        mode="lines",
                        hovertemplate=hover_template,
                        customdata=customdata_array,
                        showlegend=False,
                        opacity=0.8
                    ))

        # Add city markers
        for _, city in city_data.iterrows():
            fig.add_trace(go.Scatter(
                x=[city['x']],
                y=[city['y']],
                mode="markers+text",
                marker=dict(size=6, color="black"),
                text=city['city_name'],
                textposition="middle left",
                textfont=dict(size=10),
                hoverinfo="skip",
                showlegend=False
            ))

        fig.update_layout(
            title=f"{selected} - {fill_label}",
            xaxis=dict(visible=False, scaleanchor="y", scaleratio=1),
            yaxis=dict(visible=False),
            hovermode="closest",
            plot_bgcolor="white",
            height=600,
            margin=dict(l=0, r=0, t=30, b=0),
            clickmode="event+select",
            uirevision=selected  # Preserve UI state for each state
        )

    return fig
```

```{python}
@reactive.effect
def _():
    # Reset when button is clicked
    input.reset_btn()

    from shiny import ui as update_ui
    update_ui.update_select("state", selected="All US")

# Handle map clicks for drill-down
@reactive.effect
def _():
    try:
        click_data = input.map_clicked()

        if not click_data:
            return

        customdata = click_data.get("customdata")
        trace_name = click_data.get("traceName")

        if customdata is None and trace_name:
            clicked_value = trace_name
        elif customdata:
            clicked_value = customdata[0] if isinstance(customdata, (list, tuple)) else customdata
        else:
            return

        # Check if it's a state name (for US map) - drill down to that state
        if str(clicked_value) in state_list:
            from shiny import ui as update_ui
            update_ui.update_select("state", selected=str(clicked_value))
    except Exception as e:
        pass
```
